---
description: TypeScript DX conventions (generic names, typing boundaries)
globs: "**/*.{ts,tsx}"
alwaysApply: false
---

## TypeScript DX conventions

### Generic type naming (DX first)
- Avoid single-letter generic names like `T`, `E`, `K`, `V` in non-trivial code.
- Prefer **descriptive** generic names so call sites are self-explanatory:
  - `Data`, `Error`, `Input`, `Output`
  - `Entity`, `Id`, `Row`, `Params`, `Context`
  - `ResponseBody`, `RequestBody`
  - If you want a prefix, use `TData`, `TError`, `TInput`, `TOutput` (still descriptive).
- Single-letter generics are acceptable only in very small/local scopes (e.g. a 3-line helper) where meaning is obvious.

### Prefer type aliases for readability
- If a generic signature becomes hard to read, extract:
  - `type CreateUserInput = z.infer<typeof createUserSchema>;`
  - `type UserRow = { ... }`

### Boundary typing rules
- At boundaries (Bedrock/DB/HTTP), parse to `unknown` then validate (Zod) and return typed results.
- Prefer returning `Result<Data, Error>`-style objects over throwing across layers.

### Enum conventions
- **Prefer TypeScript enums over string literal unions** for domain types (status, intensity, etc.)
  - Rationale: Enums are explicit, refactorable, iterable, and feel less "magic"
  - Use string enums with **PascalCase values** (consistent with keys): `enum TaskStatus { Pending = "Pending", InProgress = "InProgress" }`
  - Works well with Zod: `z.nativeEnum(TaskStatus)`
  - Works well with Mikro-ORM: `@Enum(() => TaskStatus)`
  - Can iterate for UI dropdowns: `Object.values(TaskStatus)`
- String literal unions are acceptable for:
  - Simple one-off types that won't be iterated
  - External API types you don't control
  - Very small scopes (e.g., single component props)

