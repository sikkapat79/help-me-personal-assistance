---
description: Next.js Server Actions conventions (App Router)
globs: "**/*.{ts,tsx}"
alwaysApply: false
---

## Server Actions conventions

### When to use what
- Prefer **Server Actions** for app UI mutations and “call Bedrock + read/write DB” flows.
- Use `app/api/**` only for:
  - third-party webhooks
  - external clients needing HTTP
  - non-UI integrations requiring stable REST endpoints

### Boundaries
- Client Components should call Server Actions; they should not import `lib/bedrock/**` or `lib/db/**`.
- Server Actions should:
  - validate input (schema)
  - call a **use-case** in `lib/features/<feature>/use-cases/**` (preferred) which may call `lib/bedrock/**` / `lib/db/**`
  - return a typed result (success/error)

### Readability rule (thin actions)
- Keep Server Actions **thin** (orchestration only): validate → call use-case → return result.
- Put business logic (auth rules, multi-step flows, Bedrock+DB composition) in `lib/features/**`.

### Performance + caching basics
- Assume actions can be called frequently; keep them efficient and avoid unnecessary DB connections.
- Avoid putting large, long-running work in the request path; consider background jobs if needed later.
- Use `revalidatePath()` after successful mutations to refresh server component data.

### Optimistic updates pattern (use react-19-patterns skill for implementation)
- Client Components: use `useOptimistic` + `useTransition` for instant feedback
- Server Actions: handle mutation and return success/error
- Call `revalidatePath()` to ensure optimistic state syncs with server
- Provide micro-interactions: close modals, loading states, visual changes

### Server-to-client data passing
- Never pass entities with methods/toJSON to Client Components
- Convert entities to plain objects in Server Components
- Create serializable type definitions (e.g., `TaskData`) for props

